/*
 * Beautiful Capi generates beautiful C API wrappers for your C++ classes
 * Copyright (C) 2015 Petr Petrovich Petrov
 *
 * This file is part of Beautiful Capi.
 *
 * Beautiful Capi is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Beautiful Capi is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Beautiful Capi.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * WARNING: This file was automatically generated by Beautiful Capi!
 * Do not edit this file! Please edit the source API description.
 */

#include <stdexcept>
#include <cassert>
#include <stdint.h>
#include "cmath"
#include "string"
#include "PersonImpl.h"
#include "vector"

#ifndef BEAUTIFUL_CAPI_IMPLEMENTATIONCODE_EXCEPTION_INFO_DEFINED
#define BEAUTIFUL_CAPI_IMPLEMENTATIONCODE_EXCEPTION_INFO_DEFINED

struct beautiful_capi_implementationcode_exception_info_t
{
    uint32_t code; /* value from beautiful_capi_implementationcode_exception_code_t enumeration */
    void* object_pointer; /* exception object pointer */
};

enum beautiful_capi_implementationcode_exception_code_t
{
    no_exception = 0,
    unknown_exception = 1,
    copy_exception_error = 2,
    stl_exception = 100
};

#endif /* BEAUTIFUL_CAPI_IMPLEMENTATIONCODE_EXCEPTION_INFO_DEFINED */

#ifdef _WIN32
    #ifdef __GNUC__
        #define STL_API extern "C" __attribute__ ((dllexport))
        #define STL_API_CONVENTION __attribute__ ((cdecl))
    #else
        #define STL_API extern "C" __declspec(dllexport)
        #define STL_API_CONVENTION __cdecl
    #endif
#elif __APPLE__
    #if defined(__GNUC__) && __GNUC__ >= 4
        #define STL_API extern "C" __attribute__ ((visibility ("default")))
    #else
        #define STL_API extern "C"
    #endif
    #ifdef __i386__
        #define STL_API_CONVENTION __attribute__ ((cdecl))
    #else /* __i386__ */
        #define STL_API_CONVENTION
    #endif /* __i386__ */
#elif __unix__ || __linux__
    #if defined(__GNUC__) && __GNUC__ >= 4
        #define STL_API extern "C" __attribute__ ((visibility ("default")))
    #else
        #define STL_API extern "C"
    #endif
    #ifdef __i386__
        #define STL_API_CONVENTION __attribute__ ((cdecl))
    #else /* __i386__ */
        #define STL_API_CONVENTION
    #endif /* __i386__ */
#else
    #error "Unknown platform"
#endif

int AutoGen_Internal_ImplementationCode_STLGetMajorVersionImpl()
{
    return 1;
}

int AutoGen_Internal_ImplementationCode_STLGetMinorVersionImpl()
{
    return 0;
}

int AutoGen_Internal_ImplementationCode_STLGetPatchVersionImpl()
{
    return 0;
}

STL_API double STL_API_CONVENTION stl_sin_degree(beautiful_capi_implementationcode_exception_info_t* exception_info, double angle_in_degree)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        const double pi = std::acos(-1);
        return std::sin(angle_in_degree * pi / 180.0);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<double>(0);
}

STL_API int STL_API_CONVENTION stl_get_major_version()
{
    return AutoGen_Internal_ImplementationCode_STLGetMajorVersionImpl();
}

STL_API int STL_API_CONVENTION stl_get_minor_version()
{
    return AutoGen_Internal_ImplementationCode_STLGetMinorVersionImpl();
}

STL_API int STL_API_CONVENTION stl_get_patch_version()
{
    return AutoGen_Internal_ImplementationCode_STLGetPatchVersionImpl();
}

STL_API void* STL_API_CONVENTION stl_exception_range_error(beautiful_capi_implementationcode_exception_info_t* exception_info, void* error_text)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::range_error(*static_cast<std::string*>(error_text));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API const char* STL_API_CONVENTION stl_exception_what_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::exception* self = static_cast<std::exception*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->what();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<const char*>(0);
}

STL_API void* STL_API_CONVENTION stl_exception_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::exception(*static_cast<std::exception*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_exception_delete(void* object_pointer)
{
    delete static_cast<std::exception*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_string_from_cstr(beautiful_capi_implementationcode_exception_info_t* exception_info, const char* value)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_string_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::string* self = static_cast<std::string*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API const char* STL_API_CONVENTION stl_string_cstr_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::string* self = static_cast<std::string*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->c_str();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<const char*>(0);
}

STL_API void STL_API_CONVENTION stl_string_set_value(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, const char* value)
{
    std::string* self = static_cast<std::string*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        *self = value;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_string_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(*static_cast<std::string*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_string_delete(void* object_pointer)
{
    delete static_cast<std::string*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_person_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Structures::PersonImpl();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API unsigned int STL_API_CONVENTION stl_person_get_age_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->age;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<unsigned int>(0);
}

STL_API void STL_API_CONVENTION stl_person_set_age(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, unsigned int age)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->age = age;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_person_get_first_name_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(self->first_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_person_set_first_name(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* first_name)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->first_name = *static_cast<std::string*>(first_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_person_get_second_name_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(self->second_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_person_set_second_name(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* second_name)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->second_name = *static_cast<std::string*>(second_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_person_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Structures::PersonImpl(*static_cast<Structures::PersonImpl*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_person_delete(void* object_pointer)
{
    delete static_cast<Structures::PersonImpl*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_community_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Structures::CommunityImpl();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void* STL_API_CONVENTION stl_community_members(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    Structures::CommunityImpl* self = static_cast<Structures::CommunityImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return &self->members;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void* STL_API_CONVENTION stl_community_get_title_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::CommunityImpl* self = static_cast<Structures::CommunityImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(self->title);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_community_set_title(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* title)
{
    Structures::CommunityImpl* self = static_cast<Structures::CommunityImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->title = *static_cast<std::string*>(title);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_community_get_members_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::CommunityImpl* self = static_cast<Structures::CommunityImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<Structures::PersonImpl>(self->members);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_community_set_members(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* members)
{
    Structures::CommunityImpl* self = static_cast<Structures::CommunityImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->members = *static_cast<std::vector<Structures::PersonImpl>*>(members);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_community_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Structures::CommunityImpl(*static_cast<Structures::CommunityImpl*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_community_delete(void* object_pointer)
{
    delete static_cast<Structures::CommunityImpl*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_vector_int_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<int>();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_vector_int_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::vector<int>* self = static_cast<std::vector<int>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API int STL_API_CONVENTION stl_vector_int_get_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<int>* self = static_cast<std::vector<int>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->at(index);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<int>(0);
}

STL_API void STL_API_CONVENTION stl_vector_int_set_element(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index, int value)
{
    std::vector<int>* self = static_cast<std::vector<int>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->at(index) = value;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_int_push_back(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, int value)
{
    std::vector<int>* self = static_cast<std::vector<int>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->push_back(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_vector_int_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<int>(*static_cast<std::vector<int>*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_int_delete(void* object_pointer)
{
    delete static_cast<std::vector<int>*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_vector_char_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<char>();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_vector_char_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::vector<char>* self = static_cast<std::vector<char>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API char STL_API_CONVENTION stl_vector_char_get_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<char>* self = static_cast<std::vector<char>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->at(index);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<char>(0);
}

STL_API void STL_API_CONVENTION stl_vector_char_set_element(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index, char value)
{
    std::vector<char>* self = static_cast<std::vector<char>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->at(index) = value;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_char_push_back(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, char value)
{
    std::vector<char>* self = static_cast<std::vector<char>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->push_back(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_vector_char_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<char>(*static_cast<std::vector<char>*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_char_delete(void* object_pointer)
{
    delete static_cast<std::vector<char>*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_vector_double_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<double>();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_vector_double_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::vector<double>* self = static_cast<std::vector<double>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API double STL_API_CONVENTION stl_vector_double_get_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<double>* self = static_cast<std::vector<double>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->at(index);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<double>(0);
}

STL_API void STL_API_CONVENTION stl_vector_double_set_element(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index, double value)
{
    std::vector<double>* self = static_cast<std::vector<double>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->at(index) = value;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_double_push_back(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, double value)
{
    std::vector<double>* self = static_cast<std::vector<double>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->push_back(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_vector_double_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<double>(*static_cast<std::vector<double>*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_double_delete(void* object_pointer)
{
    delete static_cast<std::vector<double>*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_stl_person_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<Structures::PersonImpl>();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_vector_of_structures_stl_person_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_stl_person_get_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return const_cast<Structures::PersonImpl*>(&self->at(index));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_stl_person_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return const_cast<Structures::PersonImpl*>(&self->at(index));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_stl_person_set_element(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index, void* value)
{
    std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->at(index) = *static_cast<Structures::PersonImpl*>(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_stl_person_push_back(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* value)
{
    std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->push_back(*static_cast<Structures::PersonImpl*>(value));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_stl_person_copy(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<Structures::PersonImpl>(*static_cast<std::vector<Structures::PersonImpl>*>(object_pointer));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_stl_person_delete(void* object_pointer)
{
    delete static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_person_raw_ptr_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new Structures::PersonImpl();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API unsigned int STL_API_CONVENTION stl_person_raw_ptr_get_age_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->age;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<unsigned int>(0);
}

STL_API void STL_API_CONVENTION stl_person_raw_ptr_set_age(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, unsigned int age)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->age = age;
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_person_raw_ptr_get_first_name_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(self->first_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_person_raw_ptr_set_first_name(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* first_name)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->first_name = *static_cast<std::string*>(first_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void* STL_API_CONVENTION stl_person_raw_ptr_get_second_name_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::string(self->second_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_person_raw_ptr_set_second_name(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* second_name)
{
    Structures::PersonImpl* self = static_cast<Structures::PersonImpl*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->second_name = *static_cast<std::string*>(second_name);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_person_raw_ptr_delete(void* object_pointer)
{
    delete static_cast<Structures::PersonImpl*>(object_pointer);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_default(beautiful_capi_implementationcode_exception_info_t* exception_info)
{
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return new std::vector<Structures::PersonImpl>();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API size_t STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_get_size_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return self->size();
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<size_t>(0);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_get_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return const_cast<Structures::PersonImpl*>(&self->at(index));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void* STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_element_const(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index)
{
    const std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        return const_cast<Structures::PersonImpl*>(&self->at(index));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
    return static_cast<void*>(0);
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_set_element(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, size_t index, void* value)
{
    std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->at(index) = *static_cast<Structures::PersonImpl*>(value);
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_push_back(beautiful_capi_implementationcode_exception_info_t* exception_info, void* object_pointer, void* value)
{
    std::vector<Structures::PersonImpl>* self = static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
    beautiful_capi_implementationcode_exception_info_t exception_info_default;
    if (!exception_info)
    {
        exception_info = &exception_info_default;
    }
    try
    {
        exception_info->code = 0;
        exception_info->object_pointer = 0;
        self->push_back(*static_cast<Structures::PersonImpl*>(value));
    }
    catch (std::exception& exception_object)
    {
        exception_info->code = 100;
        try
        {
            exception_info->object_pointer = new std::exception(exception_object);
        }
        catch (...)
        {
            exception_info->code = 2;
            assert(false);
        }
    }
    catch (std::exception* exception_object)
    {
        exception_info->code = 100;
        exception_info->object_pointer = exception_object;
    }
    catch (...)
    {
        exception_info->code = 1;
    }
}

STL_API void STL_API_CONVENTION stl_vector_of_structures_raw_ptr_stl_person_delete(void* object_pointer)
{
    delete static_cast<std::vector<Structures::PersonImpl>*>(object_pointer);
}
