#!/usr/bin/env python
#
# Beautiful Capi generates beautiful C API wrappers for your C++ classes
# Copyright (C) 2015 Petr Petrovich Petrov
#
# This file is part of Beautiful Capi.
#
# Beautiful Capi is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Beautiful Capi is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Beautiful Capi.  If not, see <http://www.gnu.org/licenses/>.
#


#
# WARNING: This file was automatically generated by Xsd2Python3.py program!
# Do not edit this file! Please edit the source XSD schema.
#


from enum import Enum


def string_to_bool(string_value):
    return string_value.lower() in ["true", "on", "yes", "1"]


class TLifecycle(Enum):
    copy_semantic = 0
    raw_pointer_semantic = 1
    reference_counted = 2

    @staticmethod
    def load(value):
        if value == "copy_semantic":
            return TLifecycle.copy_semantic
        if value == "raw_pointer_semantic":
            return TLifecycle.raw_pointer_semantic
        if value == "reference_counted":
            return TLifecycle.reference_counted
        raise ValueError


class TBeautifulCapiRoot(object):
    def __init__(self):
        self.namespaces = []
    
    def load(self, dom_node):
        for element in [node for node in dom_node.childNodes if node.nodeName == "namespace"]:
            new_element = TNamespace()
            new_element.load(element)
            self.namespaces.append(new_element)
    

class TNamespace(object):
    def __init__(self):
        self.name = ""
        self.name_filled = False
        self.implementation_header = ""
        self.implementation_header_filled = False
        self.namespaces = []
        self.classes = []
        self.callbacks = []
        self.functions = []
    
    def load(self, dom_node):
        for element in [node for node in dom_node.childNodes if node.nodeName == "namespace"]:
            new_element = TNamespace()
            new_element.load(element)
            self.namespaces.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "class"]:
            new_element = TClass()
            new_element.load(element)
            self.classes.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "callback"]:
            new_element = TCallback()
            new_element.load(element)
            self.callbacks.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "function"]:
            new_element = TFunction()
            new_element.load(element)
            self.functions.append(new_element)
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("implementation_header"):
            cur_attr = dom_node.getAttribute("implementation_header")
            self.implementation_header = cur_attr
            self.implementation_header_filled = True
    

class TClass(object):
    def __init__(self):
        self.name = ""
        self.name_filled = False
        self.base = ""
        self.base_filled = False
        self.implementation_class_name = ""
        self.implementation_class_name_filled = False
        self.implementation_class_header = ""
        self.implementation_class_header_filled = False
        self.lifecycle = TLifecycle.reference_counted
        self.lifecycle_filled = False
        self.requires_cast_to_base = True
        self.requires_cast_to_base_filled = False
        self.pointer_access = False
        self.pointer_access_filled = False
        self.exception = False
        self.exception_filled = False
        self.copy_or_add_ref_noexcept = False
        self.copy_or_add_ref_noexcept_filled = False
        self.delete_or_release_noexcept = False
        self.delete_or_release_noexcept_filled = False
        self.constructors = []
        self.methods = []
        self.code_before_class_definitions = []
        self.code_after_publics = []
        self.code_after_class_definitions = []
    
    def load(self, dom_node):
        for element in [node for node in dom_node.childNodes if node.nodeName == "constructor"]:
            new_element = TConstructor()
            new_element.load(element)
            self.constructors.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "method"]:
            new_element = TMethod()
            new_element.load(element)
            self.methods.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "code_before_class_definition"]:
            new_element = TCodeBlock()
            new_element.load(element)
            self.code_before_class_definitions.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "code_after_public"]:
            new_element = TCodeBlock()
            new_element.load(element)
            self.code_after_publics.append(new_element)
        for element in [node for node in dom_node.childNodes if node.nodeName == "code_after_class_definition"]:
            new_element = TCodeBlock()
            new_element.load(element)
            self.code_after_class_definitions.append(new_element)
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("base"):
            cur_attr = dom_node.getAttribute("base")
            self.base = cur_attr
            self.base_filled = True
        if dom_node.hasAttribute("implementation_class_name"):
            cur_attr = dom_node.getAttribute("implementation_class_name")
            self.implementation_class_name = cur_attr
            self.implementation_class_name_filled = True
        if dom_node.hasAttribute("implementation_class_header"):
            cur_attr = dom_node.getAttribute("implementation_class_header")
            self.implementation_class_header = cur_attr
            self.implementation_class_header_filled = True
        if dom_node.hasAttribute("lifecycle"):
            cur_attr = dom_node.getAttribute("lifecycle")
            self.lifecycle = TLifecycle.load(cur_attr)
            self.lifecycle_filled = True
        if dom_node.hasAttribute("requires_cast_to_base"):
            cur_attr = dom_node.getAttribute("requires_cast_to_base")
            self.requires_cast_to_base = string_to_bool(cur_attr)
            self.requires_cast_to_base_filled = True
        if dom_node.hasAttribute("pointer_access"):
            cur_attr = dom_node.getAttribute("pointer_access")
            self.pointer_access = string_to_bool(cur_attr)
            self.pointer_access_filled = True
        if dom_node.hasAttribute("exception"):
            cur_attr = dom_node.getAttribute("exception")
            self.exception = string_to_bool(cur_attr)
            self.exception_filled = True
        if dom_node.hasAttribute("copy_or_add_ref_noexcept"):
            cur_attr = dom_node.getAttribute("copy_or_add_ref_noexcept")
            self.copy_or_add_ref_noexcept = string_to_bool(cur_attr)
            self.copy_or_add_ref_noexcept_filled = True
        if dom_node.hasAttribute("delete_or_release_noexcept"):
            cur_attr = dom_node.getAttribute("delete_or_release_noexcept")
            self.delete_or_release_noexcept = string_to_bool(cur_attr)
            self.delete_or_release_noexcept_filled = True
    

class TCallback(object):
    def __init__(self):
        self.name = "Callback"
        self.name_filled = False
        self.base = ""
        self.base_filled = False
        self.implementation_class_name = ""
        self.implementation_class_name_filled = False
        self.implementation_class_header = ""
        self.implementation_class_header_filled = False
        self.lifecycle = TLifecycle.reference_counted
        self.lifecycle_filled = False
    
    def load(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("base"):
            cur_attr = dom_node.getAttribute("base")
            self.base = cur_attr
            self.base_filled = True
        if dom_node.hasAttribute("implementation_class_name"):
            cur_attr = dom_node.getAttribute("implementation_class_name")
            self.implementation_class_name = cur_attr
            self.implementation_class_name_filled = True
        if dom_node.hasAttribute("implementation_class_header"):
            cur_attr = dom_node.getAttribute("implementation_class_header")
            self.implementation_class_header = cur_attr
            self.implementation_class_header_filled = True
        if dom_node.hasAttribute("lifecycle"):
            cur_attr = dom_node.getAttribute("lifecycle")
            self.lifecycle = TLifecycle.load(cur_attr)
            self.lifecycle_filled = True
    

class TConstructor(object):
    def __init__(self):
        self.name = ""
        self.name_filled = False
        self.return_copy_or_add_ref = False
        self.return_copy_or_add_ref_filled = False
        self.noexcept = False
        self.noexcept_filled = False
        self.arguments = []
    
    def load(self, dom_node):
        for element in [node for node in dom_node.childNodes if node.nodeName == "argument"]:
            new_element = TArgument()
            new_element.load(element)
            self.arguments.append(new_element)
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("return_copy_or_add_ref"):
            cur_attr = dom_node.getAttribute("return_copy_or_add_ref")
            self.return_copy_or_add_ref = string_to_bool(cur_attr)
            self.return_copy_or_add_ref_filled = True
        if dom_node.hasAttribute("noexcept"):
            cur_attr = dom_node.getAttribute("noexcept")
            self.noexcept = string_to_bool(cur_attr)
            self.noexcept_filled = True
    

class TMethod(TConstructor):
    def __init__(self):
        super().__init__()
        self.return_type = ""
        self.return_type_filled = False
    
    def load(self, dom_node):
        super().load(dom_node)
        if dom_node.hasAttribute("return_type"):
            cur_attr = dom_node.getAttribute("return_type")
            self.return_type = cur_attr
            self.return_type_filled = True
    

class TFunction(TMethod):
    def __init__(self):
        super().__init__()
        self.implementation_name = ""
        self.implementation_name_filled = False
        self.implementation_header = ""
        self.implementation_header_filled = False
    
    def load(self, dom_node):
        super().load(dom_node)
        if dom_node.hasAttribute("implementation_name"):
            cur_attr = dom_node.getAttribute("implementation_name")
            self.implementation_name = cur_attr
            self.implementation_name_filled = True
        if dom_node.hasAttribute("implementation_header"):
            cur_attr = dom_node.getAttribute("implementation_header")
            self.implementation_header = cur_attr
            self.implementation_header_filled = True
    

class TArgument(object):
    def __init__(self):
        self.name = ""
        self.name_filled = False
        self.type_name = ""
        self.type_name_filled = False
    
    def load(self, dom_node):
        if dom_node.hasAttribute("name"):
            cur_attr = dom_node.getAttribute("name")
            self.name = cur_attr
            self.name_filled = True
        if dom_node.hasAttribute("type_name"):
            cur_attr = dom_node.getAttribute("type_name")
            self.type_name = cur_attr
            self.type_name_filled = True
    

class TCodeBlock(object):
    def __init__(self):
        self.lines = []
    
    def load(self, dom_node):
        for element in [node for node in dom_node.childNodes if node.nodeName == "line"]:
            new_element = TCodeLine()
            new_element.load(element)
            self.lines.append(new_element)
    

class TCodeLine(object):
    def __init__(self):
        self.text = ""
        self.text_filled = False
    
    def load(self, dom_node):
        if dom_node.hasAttribute("text"):
            cur_attr = dom_node.getAttribute("text")
            self.text = cur_attr
            self.text_filled = True
    

def load(dom_node):
    for root_element in [root for root in dom_node.childNodes if root.localName == "api"]:
        root_params = TBeautifulCapiRoot()
        root_params.load(root_element)
        return root_params
